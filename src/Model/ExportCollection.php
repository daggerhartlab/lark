<?php

namespace Drupal\lark\Model;

use Drupal\lark\Exception\LarkImportException;

/**
 * Class ExportCollection
 *
 * @package Drupal\lark\Model
 */
class ExportCollection extends \ArrayObject {

  /**
   * @param \Drupal\lark\Model\ExportArray[] $array
   * @param int $flags
   * @param string $iteratorClass
   */
  public function __construct(object|array $array = [], int $flags = 0, string $iteratorClass = "ArrayIterator") {
    $typed_keyed = [];

    foreach ($array as $export) {
      if (!($export instanceof ExportArray)) {
        throw new \InvalidArgumentException('Only ExportArray instances can be added to an ExportCollection, "' . get_debug_type($export) . '" given instead.');
      }

      $typed_keyed[$export->uuid()] = $export;
    }

    parent::__construct($typed_keyed, $flags, $iteratorClass);
  }

  /**
   * {@inheritdoc}
   */
  public function offsetSet(mixed $key, mixed $value): void {
    if (!($value instanceof ExportArray)) {
      throw new \InvalidArgumentException('Only ExportArray instances can be added to an ExportCollection, "' . get_debug_type($value) . '" given instead.');
    }

    parent::offsetSet($key, $value); // TODO: Change the autogenerated stub
  }

  /**
   * Check if the collection has an item with the given UUID.
   *
   * @param string $uuid
   *   The UUID to check for.
   *
   * @return bool
   *   Whether the collection has an item with the given UUID.
   */
  public function has(string $uuid): bool {
    return $this->offsetExists($uuid);
  }

  /**
   * Get an item by UUID.
   *
   * @param string $uuid
   *   The UUID of the item to get.
   *
   * @return \Drupal\lark\Model\ExportArray|false
   *   The item, or false if not found.
   */
  public function get(string $uuid): ExportArray|false {
    return $this->offsetGet($uuid);
  }

  /**
   * @param string $uuid
   * @param \Drupal\lark\Model\ExportArray $item
   *
   * @return void
   */
  public function set(string $uuid, ExportArray $item): void {
    $this->offsetSet($uuid, $item);
  }

  /**
   * @param \Drupal\lark\Model\ExportArray $export
   *
   * @return void
   */
  public function add(ExportArray $export): void {
    $this->set($export->uuid(), $export);
  }

  /**
   * Remove an item by UUID.
   *
   * @param string $uuid
   *   The UUID of the item to remove.
   */
  public function remove(string $uuid): void {
    $this->offsetUnset($uuid);
  }

  /**
   * Merge another collection into this one.
   *
   * @param \Drupal\lark\Model\ExportCollection $collection
   */
  public function merge(ExportCollection $collection): void {
    foreach ($collection as $export) {
      $this->add($export);
    }
  }

  /**
   * Diff this collection with another.
   *
   * @param \Drupal\lark\Model\ExportCollection $collection
   *   The collection to diff against.
   *
   * @return \Drupal\lark\Model\ExportCollection
   *   The difference between the two collections.
   */
  public function diff(ExportCollection $collection): ExportCollection {
    return new static(array_diff_key($this->getArrayCopy(), $collection->getArrayCopy()));
  }

  /**
   * Filter the collection.
   *
   * @param callable $callback
   *   The callback to apply to each item.
   * @param int $mode
   *   The mode to pass to array_filter.
   *
   * @return \Drupal\lark\Model\ExportCollection
   */
  public function filter(callable $callback, int $mode = 0): ExportCollection {
    return new static(array_filter($this->getArrayCopy(), $callback, $mode));
  }

  /**
   * Map over the collection.
   *
   * @param callable $callback
   *   The callback to apply to each item.
   *
   * @return \Drupal\lark\Model\ExportCollection
   *   The new collection.
   */
  public function map(callable $callback): array {
    return array_map($callback, $this->getArrayCopy());
  }

  /**
   * Reverse the collection.
   *
   * @return \Drupal\lark\Model\ExportCollection
   *   The reversed collection.
   */
  public function reverse(): ExportCollection {
    return new static(array_reverse($this->getArrayCopy()));
  }

  /**
   * Get the root-level exports.
   *
   * @return \Drupal\lark\Model\ExportCollection
   *   The root-level exports.
   */
  public function getRootLevel(): ExportCollection {
    $items = $this->getArrayCopy();
    return $this->filter(function ($export, $uuid) use ($items) {
      foreach ($items as $other_export) {
        if ($other_export->hasDependency($uuid)) {
          return FALSE;
        }
      }

      return TRUE;
    }, ARRAY_FILTER_USE_BOTH);
  }

  /**
   * Gather dependencies for a single $uuid.
   *
   * @param string $uuid
   *   UUID of the export.
   * @param array $found
   *   Reference array to track all dependencies to prevent duplicates.
   *
   * @return \Drupal\lark\Model\ExportCollection
   *   Array of export with dependencies.
   */
  public function getWithDependencies(string $uuid, array &$found = []): ExportCollection {
    $dependencies = new ExportCollection();
    if (!$this->has($uuid)) {
      return $dependencies;
    }

    $export = $this->get($uuid);
    foreach ($export->dependencies() as $dependency_uuid => $entity_type) {
      // Look for the dependency export.
      // @todo - Handle missing dependencies?
      if (
        $this->has($dependency_uuid)
        // Don't recurse into dependency if it's already been registered.
        && !array_key_exists($dependency_uuid, $found)
      ) {
        // Recurse and get dependencies of this dependency.
        if (!empty($this->get($dependency_uuid)->dependencies())) {

          // Register the dependency to prevent redundant calls.
          $found[$dependency_uuid] = NULL;
          $dependencies->merge($this->getWithDependencies($dependency_uuid, $found));
        }

        // Add the dependency itself.
        $dependencies->add($this->get($dependency_uuid));
        $found[$dependency_uuid] = $this->get($dependency_uuid);
      }
    }

    // Add the entity itself last.
    $dependencies->add($export);
    return $dependencies;
  }

}
